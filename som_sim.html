<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minsky's Agent Society Simulator (3D)</title>
    <!-- Tailwind CSS for modern aesthetics and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom styles for a dark, futuristic look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #e6edf3;
            overflow: hidden; /* Prevent body scroll */
        }
        #three-container {
            width: 100vw;
            height: calc(100vh - 120px); /* Account for header/controls */
            background-color: #0d1117;
        }
        canvas {
            display: block;
        }
        /* Crucial: Hide padding/margins on body/html for iframe integration */
        html, body {
            padding: 0;
            margin: 0;
        }
        /* Update button styles to be slightly smaller and fit better inside the iframe context */
        #controls {
            padding: 10px;
        }
    </style>
</head>
<body class="p-4">

    <div id="controls" class="mb-2 flex flex-col md:flex-row items-center justify-between bg-gray-800 p-2 rounded-lg shadow-xl">
        <div class="text-base font-bold text-indigo-400 mb-1 md:mb-0">
            Agent Activation Simulator
        </div>
        <div class="flex flex-col sm:flex-row space-y-1 sm:space-y-0 sm:space-x-2 text-sm">
            <button id="solveButton" class="bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-1 px-3 rounded-md transition duration-200 shadow-lg shadow-indigo-500/50">
                Simulate Epoch
            </button>
            <button id="resetButton" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-1 px-3 rounded-md transition duration-200 shadow-lg">
                Reset Network
            </button>
        </div>
    </div>

    <div id="three-container" class="rounded-lg border border-gray-700"></div>

    <div id="status" class="mt-2 p-2 bg-gray-800 rounded-lg text-xs font-mono text-gray-400">
        Status: Ready. Click 'Simulate Epoch' to see Agents activate and K-lines form.
    </div>

    <script type="module">
        // --- Dependency Imports ---
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Core Simulation Constants ---
        const NUM_AGENTS = 80;
        const K_LINE_THRESHOLD = 0.5; // Minimum weight for a K-line to be visually rendered
        const REINFORCEMENT_FACTOR = 0.1; // How much weight is added on success

        // --- Three.js Setup Variables ---
        let scene, camera, renderer, controls;
        const container = document.getElementById('three-container');
        let agents = [];
        let connections = new Map(); // Key: 'i-j' (sorted indices), Value: {weight: 0, line: THREE.Line}

        // --- Initialization ---

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 25;

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // 5. Controls (for the "fly through" experience)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // smooth movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 100;

            // 6. Network Generation
            generateAgents();

            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('solveButton').addEventListener('click', simulateLearningEpoch);
            document.getElementById('resetButton').addEventListener('click', resetNetwork);
        }

        // --- Agent and K-line Logic ---

        /**
         * Creates the initial population of Agents (nodes) in 3D space.
         */
        function generateAgents() {
            // Clear existing elements
            agents.forEach(agent => scene.remove(agent.mesh));
            agents = [];
            connections.forEach(conn => scene.remove(conn.line));
            connections.clear();

            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: 0x8888ff, emissive: 0x000033 });
            const boundingBox = 15;

            for (let i = 0; i < NUM_AGENTS; i++) {
                const mesh = new THREE.Mesh(geometry, material.clone());
                
                // Randomly place agents within a defined cube volume
                mesh.position.x = (Math.random() - 0.5) * boundingBox * 2;
                mesh.position.y = (Math.random() - 0.5) * boundingBox * 2;
                mesh.position.z = (Math.random() - 0.5) * boundingBox * 2;

                scene.add(mesh);
                
                agents.push({
                    id: i,
                    mesh: mesh,
                    activation: 0.0, // Agent's current level of activity
                    isInput: (i < 5), // A small subset are "Input Agents"
                    isOutput: (i >= NUM_AGENTS - 5), // A small subset are "Output Agents"
                    connections: new Map() // Key: other agent ID, Value: weight
                });

                // Initialize connections with all other agents (K-lines)
                for (let j = i + 1; j < NUM_AGENTS; j++) {
                    agents[i].connections.set(j, 0);
                }
            }

            // After all agents are created, initialize the visual line objects
            initConnections();
        }

        /**
         * Initializes the THREE.Line objects for all potential K-lines.
         */
        function initConnections() {
            const tempMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 1, transparent: true, opacity: 0.0 });
            
            for (let i = 0; i < NUM_AGENTS; i++) {
                for (let j = i + 1; j < NUM_AGENTS; j++) {
                    const key = `${i}-${j}`;
                    
                    // Create a placeholder geometry (will be updated)
                    const points = [
                        agents[i].mesh.position,
                        agents[j].mesh.position
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const line = new THREE.Line(geometry, tempMaterial.clone());
                    scene.add(line);
                    
                    connections.set(key, {
                        weight: 0.0, // The actual K-line strength
                        line: line,
                        agentA: agents[i],
                        agentB: agents[j],
                    });
                }
            }
        }


        /**
         * Simulates a problem-solving attempt, leading to K-line reinforcement.
         */
        function simulateLearningEpoch() {
            document.getElementById('status').textContent = "Status: Simulating a new learning trial...";

            // 1. Activate Input Agents (The Goal/Input)
            agents.forEach(agent => {
                agent.activation = 0; // Reset
                if (agent.isInput) {
                    agent.activation = 1.0; // High initial activation
                    // Visually flash the input agent
                    agent.mesh.material.emissive.setHex(0xccff00);
                }
            });

            // 2. Propagation and Activation (Simulated step)
            for (let step = 0; step < 3; step++) { // 3 cycles of propagation
                const newActivations = new Array(NUM_AGENTS).fill(0);
                
                agents.forEach((agent, i) => {
                    if (agent.activation > 0.1) {
                        for (let j = i + 1; j < NUM_AGENTS; j++) {
                            const key = `${i}-${j}`;
                            const conn = connections.get(key);
                            
                            // Activation spreads proportional to the weight (K-line strength)
                            const activation_spread = agent.activation * conn.weight * 0.1;
                            newActivations[j] += activation_spread;
                        }
                    }
                });

                // Apply new activations (with decay)
                agents.forEach((agent, i) => {
                    agent.activation = (agent.activation * 0.5) + newActivations[i];
                    agent.activation = Math.min(1.0, agent.activation); // Cap at 1.0
                });
            }


            // 3. Goal Achievement Check (Output Agents Fire)
            const success = agents.filter(a => a.isOutput).some(a => a.activation > 0.2);

            if (success) {
                document.getElementById('status').textContent = "Status: Success! Output Agents reached. K-lines are strengthening.";

                // 4. Reinforcement (Learning)
                connections.forEach(conn => {
                    const agentA = conn.agentA;
                    const agentB = conn.agentB;

                    // If both agents were significantly active, reinforce the connection
                    if (agentA.activation > 0.1 && agentB.activation > 0.1) {
                        // Increase weight, modeling the formation of a robust K-line
                        conn.weight += REINFORCEMENT_FACTOR * agentA.activation * agentB.activation;
                        conn.weight = Math.min(1.0, conn.weight); // Max weight of 1.0
                    }
                });
            } else {
                 document.getElementById('status').textContent = "Status: Failure. Output Agents too weak. No K-line reinforcement this round.";
            }
        }

        /**
         * Resets the entire network to its initial state.
         */
        function resetNetwork() {
            document.getElementById('status').textContent = "Status: Network Reset. All K-lines cleared.";
            generateAgents(); // Regenerate agents and connections
        }


        // --- Animation and Rendering ---

        /**
         * Main animation loop. Updates the visual state of the Agents and K-lines.
         */
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // Update OrbitControls

            // Update Agents (Nodes)
            agents.forEach(agent => {
                // Decay activation over time for visual feedback
                agent.activation *= 0.98;
                
                // Color agents based on activation level (Red = Active, Blue = Inactive)
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color(0x3333ff), new THREE.Color(0xff3333), agent.activation);
                agent.mesh.material.color.copy(color);

                // Make Input/Output agents slightly larger for identification
                const scale = 1.0 + (agent.isInput || agent.isOutput ? 0.3 : 0) + agent.activation * 0.5;
                agent.mesh.scale.set(scale, scale, scale);

                // Decay the initial flash for input agents
                agent.mesh.material.emissive.multiplyScalar(0.95);
            });
            
            // Update K-lines (Connections)
            connections.forEach(conn => {
                const line = conn.line;
                const material = line.material;
                
                // Only render K-lines that are above the visual threshold
                if (conn.weight > K_LINE_THRESHOLD) {
                    material.opacity = Math.min(1.0, conn.weight * 2); // Higher weight = less transparent
                    material.color.setHSL(0.6 - (conn.weight * 0.6), 1.0, 0.5); // Color shift from blue to magenta/red
                    line.visible = true;
                    
                    // Thicken the line to visualize weight (thickness is simulated via depthTest)
                    material.linewidth = 1 + conn.weight * 5; 
                } else {
                    line.visible = false;
                }
            });

            renderer.render(scene, camera);
        }

        /**
         * Handles screen resize to maintain aspect ratio and fill the container.
         */
        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Initialize the app on window load
        window.onload = function () {
            init();
            animate();
        }

    </script>
</body>
</html>